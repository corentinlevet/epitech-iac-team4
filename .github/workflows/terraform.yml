name: "Terraform Multi-Environment CI/CD"

on:
  push:
    branches: ["main"]
    paths:
      - "terraform/**"
      - "helm-charts/**"
      - "applications/**"
      - "kubernetes-manifests/**"
      - ".github/workflows/**"
  pull_request:
    branches: ["main"]
    paths:
      - "terraform/**"
      - "helm-charts/**"
      - "applications/**"
      - "kubernetes-manifests/**"
  release:
    types: [published]

permissions:
  id-token: write
  contents: read
  pull-requests: write
  packages: write

env:
  AWS_REGION_DEV: us-east-1
  AWS_REGION_PROD: us-west-2
  TERRAFORM_VERSION: 1.6.0
  AWS_PAGER: ""

jobs:
  terraform-validate:
    name: "üîç Terraform Validation"
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Format Check
        working-directory: ./terraform
        run: |
          echo "üé® Checking Terraform formatting..."
          terraform fmt -check -recursive || {
            echo "‚ùå Terraform files are not properly formatted"
            echo "Run: terraform fmt -recursive"
            exit 1
          }

      - name: Terraform Validate - Environments
        working-directory: ./terraform/environments
        run: |
          echo "‚úÖ Validating environments module..."
          terraform init -backend=false
          terraform validate

      - name: Terraform Validate - VPC Module
        working-directory: ./terraform/modules/vpc
        run: |
          echo "‚úÖ Validating VPC module..."
          terraform init -backend=false
          terraform validate

      - name: Terraform Validate - EKS Module
        working-directory: ./terraform/modules/eks
        run: |
          echo "‚úÖ Validating EKS module..."
          terraform init -backend=false
          terraform validate

      - name: Terraform Validate - RDS Module
        working-directory: ./terraform/modules/rds
        run: |
          echo "‚úÖ Validating RDS module..."
          terraform init -backend=false
          terraform validate

      - name: TFLint
        uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: latest

      - name: Run TFLint
        working-directory: ./terraform
        run: |
          echo "üîé Running TFLint security checks..."
          tflint --init
          tflint --recursive || echo "‚ö†Ô∏è TFLint warnings found (non-blocking)"

  terraform-plan:
    name: "üìã Plan - ${{ matrix.environment }}"
    runs-on: ubuntu-latest
    needs: terraform-validate
    if: github.event_name == 'pull_request'

    strategy:
      matrix:
        environment: [dev, prod]

    defaults:
      run:
        working-directory: ./terraform/environments

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ matrix.environment == 'dev' && secrets.AWS_ROLE_ARN_DEV || secrets.AWS_ROLE_ARN_PROD }}
          aws-region: ${{ matrix.environment == 'dev' && env.AWS_REGION_DEV || env.AWS_REGION_PROD }}
          role-session-name: GitHubActions-TerraformPlan-${{ matrix.environment }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Init
        run: |
          echo "üöÄ Initializing Terraform for ${{ matrix.environment }}..."
          terraform init -backend-config="../backends/${{ matrix.environment }}.config" -reconfigure

      - name: Terraform Plan
        id: plan
        run: |
          echo "üìä Running Terraform plan for ${{ matrix.environment }}..."
          terraform plan -var-file="${{ matrix.environment }}.tfvars" -no-color -input=false -out=${{ matrix.environment }}.tfplan

      - name: Upload Plan Artifact
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ matrix.environment }}
          path: terraform/environments/${{ matrix.environment }}.tfplan
          retention-days: 5

  deploy-dev-infrastructure:
    name: "üöÄ Deploy Infrastructure - DEV"
    runs-on: ubuntu-latest
    needs: terraform-validate
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: development
      url: https://dev.student-team4.local

    defaults:
      run:
        working-directory: ./terraform/environments

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ env.AWS_REGION_DEV }}
          role-session-name: GitHubActions-Deploy-Dev

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init -backend-config="../backends/dev.config" -reconfigure

      - name: Terraform Apply
        run: terraform apply -var-file="dev.tfvars" -auto-approve -input=false

      - name: Capture Terraform Outputs
        id: outputs
        run: |
          echo "cluster_name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
          echo "vpc_id=$(terraform output -raw vpc_id)" >> $GITHUB_OUTPUT

  deploy-dev-applications:
    name: "üì¶ Deploy Applications - DEV"
    runs-on: ubuntu-latest
    needs: deploy-dev-infrastructure
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: development

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ env.AWS_REGION_DEV }}

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Get Cluster Info
        id: cluster
        working-directory: ./terraform/environments
        run: |
          terraform init -backend-config="../backends/dev.config" -reconfigure
          echo "name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT

      - name: Configure kubectl
        run: aws eks update-kubeconfig --region ${{ env.AWS_REGION_DEV }} --name ${{ steps.cluster.outputs.name }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Backend Image
        working-directory: ./applications/task-manager
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker buildx build --platform linux/amd64 \
            -t $ECR_REGISTRY/task-manager:$IMAGE_TAG \
            -t $ECR_REGISTRY/task-manager:latest \
            --push .

      - name: Build and Push Frontend Image
        working-directory: ./applications/task-manager-frontend
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker buildx build --platform linux/amd64 \
            -t $ECR_REGISTRY/task-manager-frontend:$IMAGE_TAG \
            -t $ECR_REGISTRY/task-manager-frontend:latest \
            --push .

      - name: Deploy Monitoring Stack
        run: |
          echo "üìä Deploying monitoring stack..."
          
          # Create monitoring namespace if it doesn't exist
          kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
          
          # Deploy monitoring components
          kubectl apply -f kubernetes-manifests/monitoring/prometheus-rbac.yaml
          kubectl apply -f kubernetes-manifests/monitoring/final-prometheus.yaml
          kubectl apply -f kubernetes-manifests/monitoring/final-grafana.yaml
          
          echo "‚è≥ Waiting for monitoring pods..."
          kubectl wait --for=condition=ready pod -l app=prometheus -n monitoring --timeout=300s || true
          kubectl wait --for=condition=ready pod -l app=grafana -n monitoring --timeout=300s || true

      - name: Install Helm
        uses: azure/setup-helm@v4

      - name: Deploy Applications with Helm
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          helm upgrade --install task-manager ./helm-charts/task-manager/ \
            --wait --timeout 10m \
            --set image.repository=$ECR_REGISTRY/task-manager \
            --set image.tag=$IMAGE_TAG
          
          helm upgrade --install task-manager-frontend ./helm-charts/task-manager-frontend/ \
            --wait --timeout 10m \
            --set image.repository=$ECR_REGISTRY/task-manager-frontend \
            --set image.tag=$IMAGE_TAG

  deploy-prod-infrastructure:
    name: "ÔøΩÔøΩ Deploy Infrastructure - PROD"
    runs-on: ubuntu-latest
    needs: terraform-validate
    if: github.event_name == 'release' && github.event.action == 'published'
    environment:
      name: production
      url: https://prod.student-team4.local

    defaults:
      run:
        working-directory: ./terraform/environments

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_PROD }}
          aws-region: ${{ env.AWS_REGION_PROD }}
          role-session-name: GitHubActions-Deploy-Prod

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init -backend-config="../backends/prod.config" -reconfigure

      - name: Terraform Apply
        run: |
          echo "üöÄ Deploying infrastructure to PROD with version ${{ github.event.release.tag_name }}..."
          terraform apply -var-file="prod.tfvars" -auto-approve -input=false

      - name: Capture Terraform Outputs
        id: outputs
        run: |
          echo "cluster_name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
          echo "vpc_id=$(terraform output -raw vpc_id)" >> $GITHUB_OUTPUT

  deploy-prod-applications:
    name: "üì¶ Deploy Applications - PROD"
    runs-on: ubuntu-latest
    needs: deploy-prod-infrastructure
    if: github.event_name == 'release' && github.event.action == 'published'
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_PROD }}
          aws-region: ${{ env.AWS_REGION_PROD }}

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Get Cluster Info
        id: cluster
        working-directory: ./terraform/environments
        run: |
          terraform init -backend-config="../backends/prod.config" -reconfigure
          echo "name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT

      - name: Configure kubectl
        run: aws eks update-kubeconfig --region ${{ env.AWS_REGION_PROD }} --name ${{ steps.cluster.outputs.name }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Pull and Tag Images for Production
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
        run: |
          echo "üè∑Ô∏è Tagging images for production release $RELEASE_TAG..."
          docker pull $ECR_REGISTRY/task-manager:latest
          docker tag $ECR_REGISTRY/task-manager:latest $ECR_REGISTRY/task-manager:$RELEASE_TAG
          docker push $ECR_REGISTRY/task-manager:$RELEASE_TAG
          
          docker pull $ECR_REGISTRY/task-manager-frontend:latest
          docker tag $ECR_REGISTRY/task-manager-frontend:latest $ECR_REGISTRY/task-manager-frontend:$RELEASE_TAG
          docker push $ECR_REGISTRY/task-manager-frontend:$RELEASE_TAG

      - name: Deploy Monitoring Stack
        run: |
          echo "üìä Deploying monitoring stack to production..."
          
          # Create monitoring namespace if it doesn't exist
          kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
          
          # Deploy monitoring components
          kubectl apply -f kubernetes-manifests/monitoring/prometheus-rbac.yaml
          kubectl apply -f kubernetes-manifests/monitoring/final-prometheus.yaml
          kubectl apply -f kubernetes-manifests/monitoring/final-grafana.yaml
          
          echo "‚è≥ Waiting for monitoring pods..."
          kubectl wait --for=condition=ready pod -l app=prometheus -n monitoring --timeout=300s || true
          kubectl wait --for=condition=ready pod -l app=grafana -n monitoring --timeout=300s || true

      - name: Install Helm
        uses: azure/setup-helm@v4

      - name: Deploy to Production
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
        run: |
          echo "üöÄ Deploying to production with release tag $RELEASE_TAG..."
          helm upgrade --install task-manager ./helm-charts/task-manager/ \
            --wait --timeout 10m \
            --set image.repository=$ECR_REGISTRY/task-manager \
            --set image.tag=$RELEASE_TAG \
            --set replicaCount=3
          
          helm upgrade --install task-manager-frontend ./helm-charts/task-manager-frontend/ \
            --wait --timeout 10m \
            --set image.repository=$ECR_REGISTRY/task-manager-frontend \
            --set image.tag=$RELEASE_TAG \
            --set replicaCount=3

      - name: Verify Production Deployment
        run: |
          echo "‚úÖ Verifying production deployment..."
          kubectl get pods
          kubectl get svc
          kubectl get ingress
